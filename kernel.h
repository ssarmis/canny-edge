#pragma once

#include "general.h"

static r32 KERNEL_SOBEL_X_3x3[] = {
    1, 2, 1,
    0, 0, 0,
    -1, -2, -1
};

static r32 KERNEL_SOBEL_Y_3x3[] = {
    -1, 0, 1,
    -2, 0, 2,
    -1, 0, 1
};

static r32 KERNEL_GAUSSIAN_7x7[] = {
    0.00000067,	0.00002292,	0.00019117,	0.00038771,	0.00019117,	0.00002292,	0.00000067,
    0.00002292,	0.00078633,	0.00655965,	0.01330373,	0.00655965,	0.00078633,	0.00002292,
    0.00019117,	0.00655965,	0.05472157,	0.11098164,	0.05472157,	0.00655965,	0.00019117,
    0.00038771,	0.01330373,	0.11098164,	0.22508352,	0.11098164,	0.01330373,	0.00038771,
    0.00019117,	0.00655965,	0.05472157,	0.11098164,	0.05472157,	0.00655965,	0.00019117,
    0.00002292,	0.00078633,	0.00655965,	0.01330373,	0.00655965,	0.00078633,	0.00002292,
    0.00000067,	0.00002292,	0.00019117,	0.00038771,	0.00019117,	0.00002292,	0.00000067
};

static r32 KERNEL_GAUSSIAN_3x3[] = {
    1.0/16.0, 1.0/8.0, 1/16.0, 
    1.0/8.0, 1.0/4.0, 1/8.0, 
    1.0/16.0, 1.0/8.0, 1/16.0
};

static inline void kernelPass(u8* source, u8* destination, u32 w, u32 h, r32* kernel, u8 ks){
    u8 halfSize = (ks / 2);
    for(int y = 0; y < h; ++y){
        for(int x = 0; x < w; ++x){

            r32 sum = 0;
            for(int ky = -ks / 2; ky <= ks / 2; ++ky){
                int kyy = (y + ky);
                CLAMP(kyy, 0, h - 1);

                for(int kx = -ks / 2; kx <= ks / 2; ++kx){
                    int kxx = (x + kx);
                    CLAMP(kxx, 0, w - 1);

                    sum += (r32)(source[kxx + kyy * w]) * kernel[(kx + halfSize) + (ky + halfSize) * ks];
                }
            }

            CLAMP(sum, 0, 255);

            destination[x + y * w] = sum;
        }
    }
}

